Neste projeto, foram utilizadas ferramentas e técnicas para auxiliar no desenvolvimento. Estas abordagens incluem o uso do Figma, uma plataforma colaborativa para design de interfaces e protótipos pertencente à empresa Figma, INC, do Modelo de Negócios Canvas, uma ferramenta de planejamento estratégico, do DER (Diagrama de Entidade e Relacionamento), os Diagramas de UML (Linguagem de Modelagem Unificada), o Diagrama de Rede.

O Figma é empregado como uma plataforma colaborativa de design para desenvolver os protótipos da interface do usuário do aplicativo. Isso possibilitará que a equipe de design trabalhe de forma conjunta, recebendo feedback instantâneo. Dessa forma, asseguraremos que a interface do usuário seja intuitiva e visualmente atrativa\cite{lopes2023}. 

O Modelo de Negócios Canvas é uma representação detalhada e abrangente da operação, receita e valor que uma empresa proporciona aos seus clientes. Ele visa auxiliar no desenvolvimento da percepção para entendimento da vida em sociedade o papel que lhes é atribuído. No caso específico, o canvas será utilizado para criar uma representação visual do projeto dentro do mercado gastronômico de camarões. Isso ajudará a equipe a identificar parceiros-chave, recursos-chave, atividades-chave e fontes de receita. O objetivo é assegurar que o projeto esteja alinhado tanto com os objetivos científicos quanto com os de negócios\cite{biava2017}. 

O Diagrama de Entidade e Relacionamento (DER) é uma ferramenta fundamental na modelagem de dados, empregada para representar entidades, seus atributos e os relacionamentos entre elas em um sistema. As entidades são objetos do sistema que possuem atributos, que são características ou propriedades que as descrevem. Os relacionamentos, por sua vez, indicam as conexões ou associações entre essas entidades. No contexto do desenvolvimento do aplicativo, o DER será utilizado para estruturar o banco de dados, definindo entidades como doenças, análises, resultados obtidos, usuários, entre outras, e especificando os relacionamentos entre elas. Essa modelagem é crucial para garantir a eficiência no armazenamento e na recuperação de dados relacionados às doenças e às imagens associadas\cite{awari2023}. As modelagens conceitual e lógico foi realizada por meio da plataforma BrModelo, enquanto o modelo físico foi realizado pela plataforma DbDiagram.io.

O LucidChart é utilizado para criar a representação de diagramas como:  \textbf{Diagrama de classe}, \textbf{Diagrama de objetos} e \textbf{Diagrama de caso de uso}, além de fluxogramas, workflows e mapas mentais. A ferramenta auxilia para visualizar ideias, processos e sistemas mais complexos, permitindo maximizar os processos de transformação digital, gerenciando o conteúdo em nuvem e em servidores próprios. 

OS Diagramas de UML são funcionais para apresentar os limites, a estrutura, o comportamento e os objetos dentro deles de forma geral. Os diagramas que serão usados são: \textbf{Diagrama de classe}, \textbf{Diagrama de objetos} e \textbf{Diagrama de caso de uso}\cite{lucidchart2024}. O Diagrama de Classe mapeiam de uma forma clara e objetiva suas classes, atributos, operações e relações entre objetos\cite{lucidchart12024}. O Diagrama de Objetos consiste em inserir atributos de um conjunto de objetos e apresentar a maneira em que se relacionam\cite{lucidchart22024}. O Diagrama de Caso de Uso apresenta os detalhes dos usuários em seu sistema e as interações deles no sistema\cite{lucidchart32024}. 

\subparagraph*{\textbf{HTML, CSS, JAVASCRIPT e BOOTSTRAP}}

Será utilizado o HTML (Linguagem de Marcação de Hipertexto) para estruturar e organizar o conteúdo da pagina web. Um hipertexto é um texto usado para fazer referência a outros textos. com o HTML, os usuários podem criar e estruturar seções, parágrafos e links usando elementos, tags e atributos\cite{longen2023}.  
O CSS (Folha de Estilo em Cascata) é uma linguagem de estilo que foi usada para definir a aparência visual de uma página web. Ela é comumente utilizada para atribuir cores, fontes, tamanhos de texto e layouts. O CSS permite que nós separemos a aparência visual da página do conteúdo HTML, permitindo que criemos páginas web mais estéticas\cite{ariane2022}. 

O Javascript é uma linguagem de programação de alto nível que será utilizada para criar interatividade na web. Ele usualmente é incrementado para criar efeitos animados, mapas, gráficos, menus drop-down entre outros. O projeto atual utiliza HTML, CSS e JavaScript para desenvolver o site da equipe e do projeto de forma responsiva e interativa, onde apresentamos a nossa equipe como, nossos objetivos, integrantes e os projetos que estão em desenvolvimento, a partir disso o usuário poderá conhecer melhor o serviço e a equipe\cite{carlos2023}. 

O Bootstrap é um framework web com código-fonte aberto para desenvolvimento de componentes de interface e front-end para sites e aplicações web, usando HTML, CSS e JavaScript e tem como objetivo a construção de sites responsivos. O design responsivo garante que todos os elementos da interface funcionem seguindo o conceito mobile first, ou seja, que o design web inicialmente criado pensando em tablets e smartphones se adapte a outros dispositivos, como desktops\cite{ebac2023}. 

\subparagraph*{\textbf{Node.js}}

O Node.js é um ambiente de execução do JavaScript no server side, que mostra a possibilidade de criar aplicações standalone em uma máquina servidor. Com o Node.js, utilizamos o gerenciador de pacotes NPM (Node Package Manager) sendo um diretório com um ou mais bibliotecas JavaScript, utilizado para inserir diversas funcionalidades a aplicativos ou scripts\cite{alura2023}.   Foram utilizados frameworks para facilitar a utilização e melhora na eficiência do Node.js, sendo eles: Express, MySql2, EJS, Nodemon, Sequelize.

A escolha se deve por necessitar de uma aplicação moderna, eficiente e de fácil entendimento, contribuindo para um sistema de qualidade para o usuário e possuindo uma coleta de dados sucinta.

\subparagraph*{\textbf{MySQL}}
  
O MySQL Workbech é um sistema para design de banco de dados que integra design, desenvolvimento, criação e manutenção de SQL em um único ambiente de desenvolvimento. O MySQL Workbech possui um editor SQL que permite que você escreva e execute consultas SQL de forma eficiente, ele oferece vários recursos, facilitando assim a escrita e execução de consultas complexas\cite{andrade2020}. 

\subparagraph*{\textbf{XAMPP}}

O XAMPP (Apache, MySQL, PHP, Pearl) é um software de desenvolvimento web amplamente empregada na indústria, simplificando a instalação e operação de um servidor web\cite{methaseo2023}.

\subparagraph*{\textbf{Inteligência Artificial}}

A Inteligência Artificial (IA) é um campo que estuda o desenvolvimento de sistemas capazes de realizar tarefas que normalmente requerem inteligência humana. A IA que será utilizada é Sistema de Recomendação.

O Sistema de Recomendação é um software que sugere conteúdos ou produtos com base no perfil do usuário e no comportamento anterior. Ele utiliza técnicas como filtragem colaborativa e análise preditiva para personalizar recomendações\cite{mensagem2023}.

\subparagraph*{\textbf{Sistemas Embarcados}}
 
Sistemas embarcados ou embutidos são sistemas computacionais especializados que atuam em conjunto com hardware e software, se responsabilizando por alguma função ou ação específica, no caso desse projeto, o sistema embarcado é representado pelo Arduíno\cite{souza2022}. 

O Arduino é uma plataforma de construção e prototip agem eletrônica que simplifica a criação de projetos interativos para o dia a dia, incluindo aplicações na Internet das Coisas(IoT). O Arduino é um hardware de código aberto, permitindo que qualquer pessoa possa aproveitar de suas funcionalidades. Com uma ampla gama de sensores disponíveis, o Arduino facilita a integração de diferentes componentes ao sistema\cite{thomsen2023}. Se destaca o uso do arduino por conta de sua simplicidade e facilidade de progamação, resistência e confiabilidade, compatibilidade com sensores e foco no controle de hardware.

O arduíno selecionado para ser o centro do sistema permitindo conexão wi-fi e coleta de dados é o UNO R4 WiFi, possuindo WiFi e Bluetooth integrados com ESP32-S3, matriz de LED 12x8 incorporada, periféricos avançados como barramento CAN, DAC de 12 bits e Amplificador Operacional e retrocompatibilidade, pino para ligar/desligar de forma remota e tendo um microcontrolador  Renesas RA4M1 com Arm Cortex-M4 de 32 bits.

Neste projeto, o hardware será composto por 3 tipos de sensores, sendo eles para monitoramento dos tanques, medidor de temperatura de água e medidor de pH e amônia presentes na água com ambos conectados a um arduíno wi-fi para comunicação. Além de possuir um dispensador de ração que irá funcionar com horários e quantias de ração programadas e especificadas pelo usuário ao cadastrar o tanque no aplicativo.

O sensor de temperatura utilizado será o DS18B20, conhecido por sua alta precisão, utiliza o protocolo 1-Wire, o que permite a conexão de múltiplos sensores no mesmo barramento, facilitando a expansão do sistema para diferentes tanques.

Para a detecção de resíduos, será empregado o sensor MQ-135, sensível a diversos compostos tóxicos como amônia, dióxido de carbono e benzeno. Esse sensor oferece resposta rápida e boa estabilidade, contribuindo para a identificação precoce de alterações na qualidade da água.

Por fim, para a medição do pH, será utilizado o sensor pH0-14, possui uma sonda eletroquímica de vidro e é capaz de medir valores de pH entre 0 e 14, cobrindo toda a faixa relevante para ambientes aquáticos.
 
\subparagraph*{\textbf{Aplicação IOT}}

O código foi desenvolvido para um ESP32 que monitora parâmetros ambientais de um cativeiro aquático, como temperatura, pH e amônia, por meio de sensores analógicos conectados aos pinos ADC1 do microcontrolador. As leituras são processadas e, no caso da temperatura, convertidas de voltagem para graus Celsius com base em uma fórmula específica. As informações são exibidas em tempo real em um display LCD I2C de 16 colunas por 2 linhas, permitindo o acompanhamento visual constante das condições do ambiente.

Além do monitoramento, o sistema inclui um mecanismo de alimentação automática controlado por um servo motor. A cada intervalo de tempo definido por padrão, a cada 1 minuto, o servo realiza um número de giros programado para simular a liberação de ração. Esses ciclos de alimentação podem ser ajustados dinamicamente pelo usuário através do monitor serial, oferecendo flexibilidade para diferentes necessidades de manejo.

Durante o funcionamento, o dispositivo exibe no LCD as leituras dos sensores e indica quando a alimentação está em andamento. Todas as ações são registradas no monitor serial, incluindo os valores coletados, o número de giros executados e mensagens de status. Dessa forma, o código fornece uma solução prática e automatizada para o controle de alimentação e monitoramento básico da qualidade da água em ambientes de criação.

\begin{verbatim}

    #include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <ESP32Servo.h>

// Config LCD (ajuste o endereço se necessário, normalmente é 0x27 ou 0x3F)
LiquidCrystal_I2C lcd(0x27, 16, 2);

// Pinos dos sensores (ADC1 recomendado se usar WiFi)
const int amoniaPin = 32; // ADC1_4
const int phPin = 33;     // ADC1_5
const int tmpPin = 34;    // ADC1_6 (somente entrada)

// Pino do servo
const int servoPin = 18;

Servo myServo;

// Variáveis do sistema de alimentação
int ciclosDeRacao = 1;
unsigned long intervaloAlimentacao = 60000;
unsigned long ultimoAlimentacao = 0;

// Variáveis dos sensores
int AmoniaValue = 0;
int phValue = 0;
int tempValue = 0;

unsigned long ultimaLeitura = 0;
unsigned long intervaloLeitura = 2000;

void setup() {
  Serial.begin(115200);

  // Inicia LCD
  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("Sistema Iniciado");
  delay(2000);

  // Configura servo parado
  myServo.setPeriodHertz(50); // Frequência padrão para servos
  myServo.attach(servoPin);
  myServo.write(90);
  delay(1000);
  myServo.detach();
}

void loop() {
  // Leitura dos sensores
  if (millis() - ultimaLeitura >= intervaloLeitura) {
    AmoniaValue = analogRead(amoniaPin);
    phValue = analogRead(phPin);
    tempValue = analogRead(tmpPin);

    float voltage = tempValue * (3.3 / 4095.0);  // ESP32 usa 3.3V e resolução de 12 bits
    float temperatureC = (voltage - 0.5) * 100;

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("NH3: ");
    lcd.print(AmoniaValue);
    lcd.setCursor(0, 1);
    lcd.print("pH: ");
    lcd.print(phValue);
    delay(500);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Temp: ");
    lcd.print(temperatureC);
    lcd.print(" C");
    delay(500);

    Serial.print("Amonia: ");
    Serial.print(AmoniaValue);
    Serial.print(" | pH: ");
    Serial.print(phValue);
    Serial.print(" | Temp: ");
    Serial.print(temperatureC);
    Serial.println(" C");

    ultimaLeitura = millis();
  }

  if (millis() - ultimoAlimentacao >= intervaloAlimentacao) {
    alimentar();
    ultimoAlimentacao = millis();
  }

  if (Serial.available() > 0) {
    ciclosDeRacao = Serial.parseInt();
    if (ciclosDeRacao > 0) {
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Ciclos: ");
      lcd.print(ciclosDeRacao);
      Serial.print("Ciclos atualizados: ");
      Serial.println(ciclosDeRacao);
      delay(2000);
    }
  }
}

void alimentar() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Alimentando...");
  Serial.println("Iniciando alimentacao");

  myServo.attach(servoPin);

  for (int i = 0; i < ciclosDeRacao; i++) {
    lcd.setCursor(0, 1);
    lcd.print("Giro: ");
    lcd.print(i + 1);
    Serial.print("Giro ");
    Serial.println(i + 1);

    for (int pos = 0; pos <= 180; pos++) {
      myServo.write(pos);
      delay(15);
    }

    delay(700);
    myServo.write(90);
    delay(100);
  }

  myServo.detach();

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Alimentacao OK");
  Serial.println("Alimentacao concluida");
  delay(2000);
} 
\end{verbatim}